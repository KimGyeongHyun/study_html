리액트 특징

    리액트 장점
        1. component 를 함수화하여 사용할 수 있음
        -> component 단위로 수정, 추가, 삭제 가능
        -> html 으로만 구성하면 많은 div 로 인해 코드가 더러워짐. 이를 해결할 수 있음
        2. 링크를 눌렀을 때 다른 페이지로 이동하는 대신 한 페이지에서 모두 처리할 수 있음
        (데이터 변경시 효율적인 랜더링 수행 가능)
        -> component 함수화 덕분. 조건문으로 어떤 component 를 보여줄지 결정할 수 있음

    component 함수화와 동시에 필요한 정보를 파라미터로 전달할 수 있기 때문에
        선언부에 큰 틀만 잡고 출력할 정보들을 파라미터로 전달하는 방식을 사용할 수 있음
        state 변경 시 재랜더링 되기 때문에 바뀐 상태로 선언부부터 다시 정의하여 component 를 표현할 수 있음
        즉, component 에서 유동적으로 바뀌는 것들은 js 반복문, {} 로 구성하기

    component 의 return 부는 html 형식으로 작성되지만
        js 안에서 html 문법을 작성하는 것이기 때문에 실제로 html 문법을 사용하는 것이 아니라
        js 에서 html 로 '작성하게끔' 해주는 JSX 문법을 사용한다
        (원래는 React.~~~ 의 방식으로 component 가 생성됨)
        (js 에서 작성한 html 문법을 react 문법으로 바꿔주는 역할을 함)
        때문에 실제 html 문법과 조금 다를 수 있으며
        class 는 js 에서 class 선언부에 사용되기 때문에
        class='' 대신 className='' 으로 사용하는게 좋다

    각 function 을 component 라고 부름
        하나의 태그를 component 로 구성하여 리턴하는 방식
        여러 개의 태그를 한꺼번에 리턴하고 싶으면 <></> 안에 싸서 리턴하면 된다
        component 에 전달되는 것 : props
        props 에 속성값이 한꺼번에 들어간다
        속성에 변수, 리스트, 함수 모두 들어감

    어떤 요소를 클릭했을 때 js 안의 변수를 바꾸면서
        다른 요소의 내용을 갱신해야 할 때
        조건문을 걸어놓고 변수를 바꾸더라도 실행되지 않는다
        이미 모든 코드를 돌았기 때문이다
        이때 state 를 사용

    컴포넌트를 결정하는 방법 2가지
        1. useState 를 사용하여 state 와 조건문을 사용하여 컴포넌트 결정
        2. BrowserRouter 를 사용하여 주소를 변경하며 Routes 의 element 변경
            주소를 사용하면 useState 와 조건문이 필요 없어지고,
            서버를 사용하면 하위 컴포넌트로 전달할 data를 
            굳이 props 로 전달하지 않고 서버에서 가져오면 된다

========================================================================
문법

    js 분해 할당
        js 변수 선언부에서 배열이나 객체 내부의 값을 바로 받아올 수 있다
        const [x, y] = 리스트;
        const {x, y} = 객체;

        객체에서 값을 가져올 때 객체의 key 값을 선언하면 해당 값을 그대로 가져온다

        ex
        const {day} = useParams();
        useParams() 함수는 url 에서 key, value 쌍을 객체 형태로 가져온다
        useParams() 리턴 객체가 {id: 2, day: 1} 라고 할 때
        객체 내부 day 의 value(1) 값을 const {day} 의 day 값에 복사한다

        var x, y;
        [x, y] = ~ ;
        도 가능

        {x, y, ...rest} 로 선언된 경우
        앞의 두 요소는 x, y 에 할당되고
        나머지는 rest 에 할당된다

        함수 파라미터 선언부에 사용하는 경우
        해당 객체가 해체되어 바로 변수로 사용 가능하다
        function Abcd({x, y}) {...}

    state
        0 : 상태의 값을 읽을 때 사용하는 데이터
        1 : 상태 값 변경할 때 사용하는 함수 (setState)
        함수 실행 중 값이 변경되지 않는다면 통과, 변했다면 처음으로 돌아감

        값이 원시형이라면 다른 값으로 바꾸면 되지만
        원시형이 아니라면 (배열 등)
        갱신할 형태를 새로 만들어서 setState 안에 넣어야 한다

        리스트의 경우
        1. newValue = [...value] 로 복제
        2. newValue 변경
        3. setValue(newValue) 로 데이터 변경

    useEffect
        상태값이 바뀌었을 때 동작하는 함수 작성 가능
        첫번째 매개변수는 함수
        랜더링 결과가 실제 돔에 반영된 직후에 실행됨
        두번째 매개변수로 배열 전달
        배열 안에 갱신될 때 실행될 변수를 넣음

        위의 방식에 따라 처음 랜더링될 때 함수가 실행되고,
        배열 안에 있는 변수가 갱신될 때마다 함수가 다시 실행된다

        따라서, API 를 부를 때와 같이 처음 한 번만 실행하고 싶으면
        두번째 매개변수 배열에 아무 것도 넣지 않으면 된다

    map
        json 을 반복문 형식으로 하나씩 불러온다
        for 문을 사용하는 것보다 효율적이다

        .map((배열의 값, index, map 을 호출한 배열)=>{})
        words : fetch get 으로 가져온 json 객체 리스트

        words.map((word, idx)=>(<Word word={word} key={word.id} />))
        words data 를 순회, word 라는 이름으로 하나씩 객체로 뽑아 함수에 적용
        idx 는 0에서 시작, word 를 순회할 때마다 +1

======================================================================
module.css
    css 파일을 만들어 import 하게 되면
    각 컴포넌트에 대해서만 적용되는 것이 아니라 모든 컴포넌트에 css 가 적용된다
    css 를 컴포넌트 단위로 적용하고 싶으면 module.css 형식을 사용하면 된다

    컴포넌트에서 module.css 를 객체로 받는다 (styles 로 받는다고 가정)
    태그에 클래스를 부여하기 위해선 className={styles.클래스이름} 을 적는다

    css 에선 태그를 추적해 자동으로 적용해주지만
    module.css 에서 css 를 태그 이름으로 적용을 해도 자동으로 적용해 주지 않는다
    className={styles.클래스이름} 속성을 꼭 넣어야 한다

    이런 특징 때문에 css / module.css 는 다른 방향성으로 클래스를 작성해야 한다
    이에 따른 장단점이 존재한다

    css 장점

        태그와 클래스 단위로 클래스를 작성하기에 용이하다
        section>ul li img {...}

        하위 태그로 들어가면서 스타일링을 적용할 수 있기 때문에 직관적이다
        section .header .logo-box .logo {...}
    
    css 단점
        컴포넌트 단위로 스타일링이 안 되기 때문에
        클래스 이름이 프레임워크 클래스 이름과 꼬일 수 있다

    module.css 장점

        직접 클래스를 부여해야 css 가 적용되기 때문에 각각의 태그에 스타일링을 하기에 좋다
        <h1 className={styles.h1Deco}

    module.css 단점

        직접 클래스를 부여해야 하므로 같은 스타일링을 주려면 하나씩 적어야 한다
        (컴포넌트 구성 단에서 반복문으로 스타일링을 줄 수 있다)

    어떤 요소를 클릭했을 때 js 안의 변수를 바꾸면서
        다른 요소의 내용을 갱신해야 할 때
        조건문을 걸어놓고 변수를 바꾸더라도 실행되지 않는다
        이미 모든 코드를 돌았기 때문이다
        이때 state 를 사용

	state
	0 : 상태의 값을 읽을 때 사용하는 데이터
	1 : 상태 값 변경할 때 사용하는 함수
	함수 실행 중 값이 변경되지 않는다면 통과, 변했다면 처음으로 돌아감


=========================================================================
개인 공부 내용

    setState

            1. 해당 값이 변경될 때마다 웹 사이트가 변경되어야 할 때
                단순하게 보이는 게 바로 갱신 되어야 할 때만 확인하면 된다

            2. db 처럼 각 요소의 데이터를 임시 저장할 때

                Fundamental Function 탭의 경우 모든 데이터를
                서버대신 state 로 임시 저장했다

                단어장 탭의 경우 단어 뜻 보기 여부를 
                각 Word 의 state 로 임시 저장했다 (db 사용 X)

    페이지, 컴포넌트 state 구성

        보통 페이지 내에서 모든 데이터를 컨트롤 하므로 페이지에 모든 state 를 구현,
        컴포넌트에서 이벤트 수행시 페이지의 state 를 변화하기 위해서
        컴포넌트 선언할 때 setState 를 함수로 넘겨 수행한다

        컴포넌트의 내용을 기존 내용과 완전히 다른 내용으로 바꾸고 싶으면
        페이지 내에 mode 변수를 state 로 선언, 
        조건문으로 컴포넌트의 내용을 변경한다

        컴포넌트 내부 li 내용을 갱신하는 방법도 위의 방법과 같다
        컴포넌트에서 구현하는 게 아니라 메인 페이지에서 state 로 구현하고 
        setState 함수를 파라미터로 넘긴다
        대부분의 이벤트 함수 구현은 페이지에서 한다
        페이지에 state 변수를 구현하면 모든 컴포넌트 범위에서 setState 할 수 있다

        만약 각 컴포넌트 안에서만 다루는 변수가 필요할 땐 컴포넌트 내에서
        state 설정하면 된다 (단어장 단어 안에 단어 뜻 보기 여부)

        state 범위를 어디까지로 설정해야 하는 지는
        state 를 데이터처럼 사용할 때 어느 컴포넌트까지 영향을 미칠지
        고려하고 결정하면 된다

    ts, tsx

        js 는 코드가 이상해도 어떻게든 수행함 -> 오작동 발생
        ts, tsx 는 컴파일러 단에서 변수, 함수 를 확실하게 검사
        변수 선언시 형식을 같이 선언해야 하고,
        함수 전달한 곳과 받은 곳 모두 함수의 파라미터, 리턴 타입을
        type (혹은 interface) 으로 명시해야 한다

    