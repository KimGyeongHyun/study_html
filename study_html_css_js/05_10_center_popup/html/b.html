<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" href="../css/b.css">
</head>
<body>
    <img src="../../img/trip.jpg" alt="">
    <p>
    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.

    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.

    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.

    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.

    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.

    최장 공통 부분수열의 점화식을 코드로 작성해보았습니다. 위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사합니다.

    문자열A, 문자열B의 한글자씩 비교해봅니다.
    두 문자가 다르다면 LCS[i - 1][j]와 LCS[i][j - 1] 중에 큰값을 표시합니다.
    두 문자가 같다면 LCS[i - 1][j - 1] 값을 찾아 +1 합니다.
    위 과정을 반복합니다.
    최장 공통 문자열을 구하는 과정과 다른부분은 비교하는 두 문자가 다를 때 입니다. 
    비교하는 두 문자가 같을 때는 같은 과정을 보여줍니다. 왜 어떤 부분은 다른 로직을, 어떤부분은 같은 로직을 사용하는지 상세히 살펴보겠습니다.

    1. LCS[i - 1][j]와 LCS[i][j - 1]는 어떤 의미인가?
    부분수열은 연속된 값이 아닙니다. 때문에 현재의 문자를 비교하는 과정 이전의 
    최대 공통 부분수열은 계속해서 유지됩니다. '현재의 문자를 비교하는 과정' 이전의 과정이 바로 LCS[i - 1][j]와 LCS[i][j - 1]가 됩니다.
    </p>

    <!-- 팝업 구성 순서 -->
    <!-- 선언된 것 먼저 맨 아래 붙음 -->
    <!-- 즉 제일 마지막에 선언된 것이 제일 위에 배치됨 -->
    <div class="add"></div>

    <!-- 팝업창이 떴을 때 회색 바탕을 씌움 -->
    <div class="popup_bg"></div>

    <div class="center_white_box">
        <div class="x">X</div>
        <div class="word_box">
            오늘은 <div class="red_word">2023년 5월 10일</div><br>
            수요일입니다
        </div>
        
    </div>

</body>
</html>